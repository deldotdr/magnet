"""
Provides the pocket reactor.

@file core.py
@author Dorian Raymer
@date 7/9/09
"""
from twisted.internet import task
from twisted.python import failure
from twisted.python import log

from magnet import mtp
from magnet import pocket


class PocketReactorCore(object):
    """
    The pocket reactor supporting messaged based Inter Process
    Communication.

    The network events generated by the Twisted select reactor (or any
    Twisted reactor implementing the IReactorFDSet) originate from the
    operating system via select, or another file descriptor poll.

    The pocket connections to the messaging IPC facility are not file
    descriptors and therefore cannot be added as readers or writers
    in the regular select (or equivalent) reactor event loop -- pockets
    operate in an abstraction realm above that of the socket.

    This must always be running. Pockets depend on channels from the AMQP
    client.
    """

    def __init__(self, reactor, client, debug=False):
        """the client attribute of the messaging service core is the amqp
        client instance, (connected and running)
        """
        self.reactor = reactor
        self.client = client
        self.debug = debug

    def pocket(self):
        """pocket instance factory

        For prototype, always return new pocket
        @todo Add args for configuring communication pattern the pocket is
        to be used for. The way this configuration is determined upstream
        could be implied by the type of connector/listener (mtp.py) used,
        or it could be implied in the address/name used when connecting
        into the messaging service.
        """
        chan = self.client.channel()
        p = pocket.Bidirectional(chan)
        p.dynamo = self
        return p

    def work_consumer_pocket(self):
        chan = self.client.channel()
        p = pocket.WorkConsumer(chan, self.debug)
        p.dynamo = self
        return p

    def work_producer_pocket(self):
        chan = self.client.channel()
        p = pocket.WorkProducer(chan, self.debug)
        p.dynamo = self
        return p

    def simple_consumer_pocket(self):
        chan = self.client.channel()
        p = pocket.SimpleConsumer(chan, self.debug)
        p.dynamo = self
        return p

    def simple_producer_pocket(self):
        chan = self.client.channel()
        p = pocket.SimpleProducer(chan, self.debug)
        p.dynamo = self
        return p

    def listenMS(self, addr, factory, backlog=50):
        """Connects given factory to the given message service address.
        """
        p = mtp.ListeningPort(addr, factory, reactor=self.reactor, dynamo=self)
        self.reactor.callWhenRunning(p.startListening)
        return p

    def connectMS(self, addr, factory, timeout=30, bindAddress=None):
        """Connect a message service client to given message service
        address.
        """
        c = mtp.Connector(addr, factory, timeout, bindAddress, self.reactor, self)
        self.reactor.callWhenRunning(c.connect)
        return c

    def connectWorkConsumer(self, name, factory, timeout=30, bindAddress=None):
        """
        Configure a worker application to receive messages sent by work
        produers to @param name.
        """
        c = mtp.WorkConsumerConnector(name, factory, timeout, bindAddress, self.reactor, self)
        self.reactor.callWhenRunning(c.connect)
        return c

    def connectWorkProducer(self, name, factory, timeout=30, bindAddress=None):
        """
        Send messages to be processed (distributed) to @param name.
        """
        c = mtp.WorkProducerConnector(name, factory, timeout, bindAddress, self.reactor, self)
        self.reactor.callWhenRunning(c.connect)
        return c

    def connectSimpleConsumer(self, name, factory, timeout=30, bindAddress=None):
        """
        Configure a worker application to receive messages sent by work
        produers to @param name.
        """
        c = mtp.SimpleConsumerConnector(name, factory, timeout, bindAddress, self.reactor, self)
        self.reactor.callWhenRunning(c.connect)
        return c

    def connectSimpleProducer(self, name, factory, timeout=30, bindAddress=None):
        """
        Send messages to be processed (distributed) to @param name.
        """
        c = mtp.SimpleProducerConnector(name, factory, timeout, bindAddress, self.reactor, self)
        self.reactor.callWhenRunning(c.connect)
        return c

    def run(self):
        """
        @todo improve this loop mechanism
        """
        self.loop.start(0.001)

    def stop(self):
        """
        Shutdown loop for pocket poll.
        @note Calling client.close() isn't reversable. Is this the best
        place for that?
        """
        self.loop.stop()
        self.client.transport.loseConnection()

def _pocket_poll(readers, writers):
    """Poll over read and write pocket objects checking for read and
    writeablity. This is the equivalent to select polling over file
    descriptors.

    The getting of the pocket reference explicitly from the abstract pocket
    might best be wrapped by a getter (maybe that's what filehandle is for)
    """
    readables = [r for r in readers if r.pocket.read_ready()]
    writeables = [w for w in writers if w.pocket.write_ready()]
    return readables, writeables

class PocketReactor(PocketReactorCore):
    """Analog of select reactor
    Event driver for pockets

    @todo This will be a service, or service collection
    @todo  or a cooperator service
    """

    def __init__(self, reactor, client, debug=False):
        """
        readers and writers are pocket obects
        """
        PocketReactorCore.__init__(self, reactor, client, debug)
        self._readers = {}
        self._writers = {}
        self.loop = task.LoopingCall(self.doIteration)

    def doIteration(self):
        """Run one iteration of checking the channel buffers

        (This is the analog to what select does with file descriptors)
        """
        r, w = _pocket_poll(self._readers.keys(), self._writers.keys())

        _drdw = self._doReadOrWrite
        _logrun = log.callWithLogger

        for pkts, method in ((r, 'doRead'), (w, 'doWrite')):
            for pkt in pkts:
                # @todo not sure why dict is passed in and out of logger?
                _logrun(pkt, _drdw, pkt, method, dict)

    def _doReadOrWrite(self, pkt, method, dict):
        """
        """
        try:
            # This just calls doRead or doWrite
            # leaving out other error checking done in select reactor
            why = getattr(pkt, method)()
        except:
            log.err()
        if why:
            self._disconnectPocket(pkt, why, method=='doRead')

    def _disconnectPocket(self, pkt, why, isRead):
        self.removeWriter(pkt)
        pkt.connectionLost(failure.Failure(why))

    def addReader(self, reader):
        """
        """
        self._readers[reader] = 1

    def addWriter(self, writer):
        """
        """
        self._writers[writer] = 1

    def removeReader(self, reader):
        """
        """
        if reader in self._readers:
            del self._readers[reader]

    def removeWriter(self, writer):
        """
        """
        if writer in self._writers:
            del self._writers[writer]

    def removeAll(self):
        """
        """

    def getReaders(self):
        """
        """
        return self._readers.keys()

    def getWriters(self):
        """
        """
        return self._writers.keys()

def install():
    """
    Make a singleton of the preactor.
    Get configuration from conf file.
    If no local conf file (dir magnet started in), fallback on .magnet.conf
    in users home dir.
    If no conf in users home, fallback on magnet.conf in magnet python
    package.
    """
    import os
    import sys
    import ConfigParser
    import magnet
    pkg_conf = os.path.join(magnet.__path__[0], 'magnet.conf')
    home_path = os.path.expanduser('~')
    home_conf = os.path.join(home_path, '.magnet.conf') # @todo hardcoded filename
    # see if there is a conf file in the cur dir
    local_conf = os.path.join(os.path.abspath('.'), 'magnet.conf')
    c = ConfigParser.ConfigParser()
    confs_read = c.read([pkg_conf, home_conf, local_conf])
    if not confs_read:
        raise Exception("""No magnet.conf file located!! This is where\
                necessary AMQP Broker configuration is looked up.""")

    from twisted.internet import reactor
    from magnet.amqp import AMQPClientCreator
    
    username = c.get('amqp_broker', 'username')
    password = c.get('amqp_broker', 'password')
    vhost = c.get('amqp_broker', 'vhost')
    clientCreator = AMQPClientCreator(reactor, username=username,
                                    password=password, vhost=vhost)

    broker_host = c.get('amqp_broker', 'host')
    broker_port = int(c.get('amqp_broker', 'port'))
    # amqp_client = yield clientCreator.connectTCP(broker_host, broker_port)
    amqp_client_d = clientCreator.connectTCP(broker_host, broker_port)

    p_reactor = PocketReactor(reactor, amqp_client_d)

    assert not sys.modules.has_key('magnet.preactor'), "preactor already installed"
    import magnet
    magnet.preactor = p_reactor
    sys.modules['magnet.preactor'] = p_reactor






